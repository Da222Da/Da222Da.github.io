"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([[336],{9362:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-18d179a0",path:"/technology/javascript/organization/data/symbol.html",title:"Symbol 唯一值",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"ES6 引入 Symbol 数据类型的原因？",slug:"es6-引入-symbol-数据类型的原因",children:[]},{level:2,title:"Symbol 给 JavaScript 带来的改变？",slug:"symbol-给-javascript-带来的改变",children:[]},{level:2,title:"深入了解 Symbol 属性",slug:"深入了解-symbol-属性",children:[{level:3,title:"Symbol.prototype.description || Symbol() 函数接受一个字符串参数的意义？",slug:"symbol-prototype-description-symbol-函数接受一个字符串参数的意义",children:[]},{level:3,title:"Symbol.hasInstance && 指向 instanceof 运算符的执行函数",slug:"symbol-hasinstance-指向-instanceof-运算符的执行函数",children:[]}]}],filePathRelative:"technology/javascript/organization/data/symbol.md",git:{updatedTime:null,contributors:[]}}},3501:(n,s,a)=>{a.r(s),a.d(s,{default:()=>b});var e=a(6252);const o=(0,e._)("h1",{id:"symbol-唯一值",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#symbol-唯一值","aria-hidden":"true"},"#"),(0,e.Uk)(" Symbol 唯一值")],-1),t={class:"table-of-contents"},l=(0,e.Uk)("ES6 引入 Symbol 数据类型的原因？"),p=(0,e.Uk)("Symbol 给 JavaScript 带来的改变？"),c=(0,e.Uk)("深入了解 Symbol 属性"),i=(0,e.Uk)("Symbol.prototype.description || Symbol() 函数接受一个字符串参数的意义？"),r=(0,e.Uk)("Symbol.hasInstance && 指向 instanceof 运算符的执行函数"),u=(0,e.uE)('<h2 id="es6-引入-symbol-数据类型的原因" tabindex="-1"><a class="header-anchor" href="#es6-引入-symbol-数据类型的原因" aria-hidden="true">#</a> ES6 引入 Symbol 数据类型的原因？</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入 Symbol 的原因。</p><p>在这种背景之下，ES6 引入了一种新的原始数据类型 Symbol，每一个 Symbol 值都是通过调用 Symbol()函数生成，且生成的 Symbol 值是独一无二的。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s1 <span class="token operator">===</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，证明了symbol值是独一无二的</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="symbol-给-javascript-带来的改变" tabindex="-1"><a class="header-anchor" href="#symbol-给-javascript-带来的改变" aria-hidden="true">#</a> Symbol 给 JavaScript 带来的改变？</h2><ul><li>使用 symbol 值来做对象的属性名。换言之，对象的属性名现在可以有两种类型<code>字符串 &amp;&amp; Symbol类型</code></li></ul><div class="custom-container danger"><p class="custom-container-title">注意！</p><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。</p><p>但是，可以通过 <code>Object.getOwnPropertySymbols() &amp;&amp; Reflect.ownKeys()</code>获取。</p></div><h2 id="深入了解-symbol-属性" tabindex="-1"><a class="header-anchor" href="#深入了解-symbol-属性" aria-hidden="true">#</a> 深入了解 Symbol 属性</h2><h3 id="symbol-prototype-description-symbol-函数接受一个字符串参数的意义" tabindex="-1"><a class="header-anchor" href="#symbol-prototype-description-symbol-函数接受一个字符串参数的意义" aria-hidden="true">#</a> Symbol.prototype.description || Symbol() 函数接受一个字符串参数的意义？</h3><p>Symbol() 函数接受一个字符串参数的意义？只表示对 Symbol 实例的描述，对 Symbol() 函数的返回值不会产生任何影响，主要是为了让读者容易区分而已。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="symbol-hasinstance-指向-instanceof-运算符的执行函数" tabindex="-1"><a class="header-anchor" href="#symbol-hasinstance-指向-instanceof-运算符的执行函数" aria-hidden="true">#</a> Symbol.hasInstance &amp;&amp; 指向 instanceof 运算符的执行函数</h3><p><code>Object[Symbol.hasInstance]</code> 指向一个方法（该方法是 instanceof 运算符执行时，所调用的 JavaScript 语言内部方法。）</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">let</span> zhangsan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nzhangsan <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">;</span> <span class="token comment">// exp01</span>\nPerson<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span>zhangsan<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// exp02</span>\n\n<span class="token comment">// exp01 等价于 exp02</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div>',14),m={},b=(0,a(3744).Z)(m,[["render",function(n,s){const a=(0,e.up)("RouterLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[o,(0,e._)("nav",t,[(0,e._)("ul",null,[(0,e._)("li",null,[(0,e.Wm)(a,{to:"#es6-引入-symbol-数据类型的原因"},{default:(0,e.w5)((()=>[l])),_:1})]),(0,e._)("li",null,[(0,e.Wm)(a,{to:"#symbol-给-javascript-带来的改变"},{default:(0,e.w5)((()=>[p])),_:1})]),(0,e._)("li",null,[(0,e.Wm)(a,{to:"#深入了解-symbol-属性"},{default:(0,e.w5)((()=>[c])),_:1}),(0,e._)("ul",null,[(0,e._)("li",null,[(0,e.Wm)(a,{to:"#symbol-prototype-description-symbol-函数接受一个字符串参数的意义"},{default:(0,e.w5)((()=>[i])),_:1})]),(0,e._)("li",null,[(0,e.Wm)(a,{to:"#symbol-hasinstance-指向-instanceof-运算符的执行函数"},{default:(0,e.w5)((()=>[r])),_:1})])])])])]),u],64)}]])}}]);